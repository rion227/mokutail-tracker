@@
-  const actionsBlocked = () => pushingRef.current || lockActive; // Realtime反映のデバウンス
+  // 自分の「早出しロック」は操作を止めない。ブロックは他端末ロックのみ。
+  const actionsBlocked = () => lockActive;
@@
-  const earlyAnnounce = async () => {
+  const earlyAnnounce = async () => {
     if (!connected || !supabaseRef.current || !roomId || earlyAnnouncedRef.current) return;
     earlyAnnouncedRef.current = true;
-    pushingRef.current = true;          // 自端末も一瞬ロック ← これが原因で加算が止まっていた
     startSync('同期中…', 1000);        // 既存の小ポップを流用
     const sb = supabaseRef.current;
     const announce = buildPayload({ sync: { busy: true, owner: clientId.current, started_at: Date.now() } });
     // fire-and-forget で十分（awaitでも可）
     sb.from('rooms').upsert({ id: roomId, payload: announce }, { onConflict: 'id' });
   };
@@
-      // 送信開始の小ポップ（1秒）
-      pushingRef.current = true;
+      // 送信開始の小ポップ（1秒）
+      pushingRef.current = true; // ← ここはCAS直前の「本送信」でのみ立てる（従来どおり）
       startSync('同期中…', 1000);
@@
-      setTimeout(() => { earlyAnnouncedRef.current = false; pushingRef.current = false; finishSync(); }, 120);
+      setTimeout(() => { earlyAnnouncedRef.current = false; pushingRef.current = false; finishSync(); }, 120);
