--- a/App.tsx
+++ b/App.tsx
@@
   const [syncBusy, setSyncBusy] = useState(false);
   const [syncMsg, setSyncMsg] = useState<string>("");
   const syncTimerRef = useRef<any>(null);
+  // 競合時の明示モーダル
+  const [showRetryModal, setShowRetryModal] = useState(false);
@@
       if (casErr) {
         console.error('CAS update error', casErr);
         // フォールバック：最新を読み直して手元を同期
         const { data: latest } = await sb.from('rooms').select('payload').eq('id', roomId).maybeSingle();
         const r = latest?.payload as RemotePayload | undefined;
         if (r) {
           remoteApplyingRef.current = true; // 自反映ループ抑止
           setInventory(r.inventory); setBaseline(r.baseline); setCounts(r.counts); setVersion(Number(r.version || 0));
         }
         localDirtyRef.current = false;
-        setTimeout(() => { pushingRef.current = false; finishSync(); }, 120);
+        // ユーザーに明示（小ポップに加えて中央モーダル）
+        setShowRetryModal(true);
+        setTimeout(() => { pushingRef.current = false; finishSync(); }, 120);
         return;
       }
 
       if (!upd || upd.length === 0) {
         // 競合：誰かが先に version を進めた → 最新に合わせる
         startSync('更新競合 → 最新を反映', 900);
         const { data: latest } = await sb.from('rooms').select('payload').eq('id', roomId).maybeSingle();
         const r = latest?.payload as RemotePayload | undefined;
         if (r) {
           remoteApplyingRef.current = true;
           setInventory(r.inventory); setBaseline(r.baseline); setCounts(r.counts); setVersion(Number(r.version || 0));
         }
         localDirtyRef.current = false; // この操作はキャンセル扱い（次の操作で正しいベースから送られる）
-        setTimeout(() => { pushingRef.current = false; finishSync(); }, 120);
+        // ユーザーに明示（小ポップに加えて中央モーダル）
+        setShowRetryModal(true);
+        setTimeout(() => { pushingRef.current = false; finishSync(); }, 120);
         return;
       }
@@
         {/* 中央の小さな同期ポップ */}
         {syncBusy && (
           <div className="fixed inset-0 pointer-events-none flex items-start justify-center">
             <div className="mt-10 px-4 py-2 rounded-xl shadow bg-neutral-900/90 text-white text-sm flex items-center gap-2">
               <svg className="w-4 h-4 animate-spin" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                 <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"/>
                 <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"/>
               </svg>
               <span>{syncMsg || '同期中…'}</span>
             </div>
           </div>
         )}
+
+        {/* 競合で送信失敗した後の明示モーダル */}
+        {showRetryModal && (
+          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40">
+            <div className="w-[92%] max-w-md rounded-2xl bg-white shadow-xl p-6 text-center">
+              <h3 className="text-base font-semibold text-neutral-900 mb-2">送信できませんでした</h3>
+              <p className="text-sm text-neutral-600">もう一度お試しください。</p>
+              <div className="mt-5">
+                <button
+                  onClick={() => setShowRetryModal(false)}
+                  className="inline-flex items-center justify-center rounded-xl bg-neutral-900 text-white px-4 py-2 hover:bg-neutral-800 shadow"
+                >
+                  OK
+                </button>
+              </div>
+            </div>
+          </div>
+        )}
